import axios, { AxiosError, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Readable } from 'stream';
import { DahuaEvents } from './dahua';

describe('Dahua Events', () => {
  jest.mock('axios')
  // Set axios.request to a mock function.
  axios.request = jest.fn()

  test('Should successfully authenticate with digest auth', async () => {
    const AUTHORIZATION_HEADER_PARAM = 'authorization'
    const REALM = 'example.com'
    const NONCE = 'abcdefghijklmnopqrstuvwxyz'
    // Mock axios.request call. 
    // We want to do a minimal amount of request verification here so we can do it all via assertions at the end instead.
    let mockedResponse = (axios.request as jest.Mock).mockImplementation((config: AxiosRequestConfig) => {

      // Check if authorization header exists and starts with Digest. 
      if (AUTHORIZATION_HEADER_PARAM in config.headers && config.headers[AUTHORIZATION_HEADER_PARAM].startsWith('Digest')) {
        // Create a stream.
        const mockReadable = new Readable()
        // Immediately destory it, as it will send a close event that we handle in dahua.
        mockReadable.destroy()
        return Promise.resolve({ data: mockReadable, status: 200 })
      }

      return Promise.reject({
        response: {
          data: { error: 'Unauthorized' },
          headers: { 'www-authenticate': `Digest realm="${REALM}", qop="auth", nonce="abcdefghijklmnopqrstuvwxyz", opaque="xyz"` },
          status: 401
        }
      })
    });

    let host = '192.168.0.0'
    let user = 'user'
    let pass = 'pass'

    let events: DahuaEvents = new DahuaEvents(host, user, pass, false)

    // Wait for the end of the current event loop cycle before continuing with the next line of code. 
    // TL;DR wait for async process to finish above.
    await new Promise(process.nextTick);
    // Expect the mock to be called twice. Once for the 401, and again with the Digest Auth Header.
    expect(axios.request).toBeCalledTimes(2)
    // Assertions the correct digest auth parameters for the second time the request was called.
    let lastCallParams = mockedResponse.mock.lastCall
    expect(lastCallParams).toHaveLength(1)

    let axiosRequestConfig: AxiosRequestConfig = (lastCallParams[0] as AxiosRequestConfig)
    expect(axiosRequestConfig.headers).toHaveProperty(AUTHORIZATION_HEADER_PARAM)

    let digestAuthHeader: String = axiosRequestConfig.headers[AUTHORIZATION_HEADER_PARAM]
    expect(digestAuthHeader).toContain('Digest')
    console.log(digestAuthHeader)

    // Reduce down to kv pairs.
    let digestAuthParams = digestAuthHeader.replace('Digest ', '').split(',').reduce((acc, pair) => {
      const index = pair.indexOf('=');
      const key = pair.substring(0, index)
      const value = pair.substring(index + 1)
      acc[key] = value
      return acc;
    }, {} as { [key: string]: string });

    expect(digestAuthParams).toHaveProperty('username')
    expect(digestAuthParams['username']).toEqual(`"${user}"`)

    expect(digestAuthParams).toHaveProperty('realm')
    expect(digestAuthParams['realm']).toEqual(`"${REALM}"`)

    expect(digestAuthParams).toHaveProperty('nonce')
    expect(digestAuthParams['nonce']).toEqual(`"${NONCE}"`)

    expect(digestAuthParams).toHaveProperty('uri')
    expect(digestAuthParams['uri']).toEqual(`"${events['EVENTS_URI']}"`)

    expect(digestAuthParams).toHaveProperty('qop')
    expect(digestAuthParams['qop']).toEqual('"auth"')

    expect(digestAuthParams).toHaveProperty('algorithm')
    expect(digestAuthParams['algorithm']).toEqual('"MD5"')

    expect(digestAuthParams).toHaveProperty('response')
    // Testing response is hard because it relies on MD5 hashing. So here we just do some basic checks.
    let response = digestAuthParams['response'].replaceAll('"', '')
    // Check if the length is 32.
    expect(response.length).toEqual(32)
    // Check if it's a hexidecimal string.
    expect(/^[0-9a-f]+$/i.test(response)).toBe(true)

    expect(digestAuthParams).toHaveProperty('nc')
    // 00000000 + 1 = 00000001
    expect(digestAuthParams['nc']).toEqual('"00000001"')

    expect(digestAuthParams).toHaveProperty('cnonce')
    // cnonce is just 48 character long hex string generated by the crypto library.
    let cnonce = digestAuthParams['cnonce'].replaceAll('"', '')
    // Check if the length is 48.
    expect(cnonce.length).toEqual(48)
    // Check if it's a hexidecimal string.
    expect(/^[0-9a-f]+$/i.test(cnonce)).toBe(true)
  });
});